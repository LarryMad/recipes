mir reichts... noch nicht ganz

damit klar wird wovon ich schreibe, eines vorab,
Lesen bildet.
Einbildung ist auch Bildung.

Nun zum finish-

Ich kann über reichhaltige Erfahrungen in den Bereichen

testing in general
plattform testing
liquid documentation
administrational support
international teaming 
interim project management
risc management

schreiben.
Mein Interesse für Ethereum begann in 2015 durch lesen eines Artikels, was ethereum denn überhaupt ist
und wie es funktioniert und weshalb es anders ist, als das was wir kennen.
Es ergab sich, daß im Mai mir 26 potente Grakas ins Haus kamen, die nun nach allen Regeln der Kunst 
umfunktioniert wurden- als miner für ethereum. Um das System zu verstehen, war ich mir nicht zu fein, an dieser Stelle
einige Erahrungen einzusammeln und in den jeweiligen Pools meine Werte einzufahren. Dabei habe ich vorrangig 
unter Windows zunächst gearbeitet, um eine breite Basis an Ansprechpartnern bei der Suche vermuten zu dürfen.
Um das erminte Ether verwalten bzw. transferieren kam ich zunächst aufgrund der Wahl der Plattform auf etherwallet.
Leider ist die Software tendenziell platzverschwenderisch drauf, wenn man die ganze Chain auf den Rechner lädt.
Ein jüngst gefundenes Dokument belegt dies
http://bc.daniel.net.nz/ bzw. deckt sich mit meinen Erfahrungen.
Soweit zu geth, welches einfach ein Wallet-Programm ist, mit dem auch Smart.Contract "gehen".

Nach einer gewissen Erfahrungszeit kam ich dazu, daß ich eine
überzeugende Übersicht aller "möglichen" Clients bzw. Nodes sucht und fand.
Neben Ethereum.Wallet und Mist auf Basis von go bzw. c++ gibt es mehrere beachtenswerte Ansätze,
die auch fortlaufend weiterentwickelt werden. 
Dazu gehören mindestens ethereumJ und pyethapp- diese auf einem Windows System zum laufen zu bringen,
stellt sich als unlösbare Aufgabe bei zahlreichen Versuchen und Umstellungen raus.
Da ich keiner Plattform den absoluten Vorzug gebe, bin ich 
zum "ersten Probieren" im September 2016 dazu übergegangen, weiter auf Linux.Systemen zu arbeiten-
gerade in Hinsicht auf Authentizität und Transparenz.

Mit meiner Wahl eines Linux Mint Debian Edition als Basis.System bestanden die
deutlich höchsten Chancen auf Standards zu treffen, die
vermutlich auch bei mindestens einem der Kernentwickler der jeweiligen
Software vorherrschen.

Exakte aktuelle Hinweise bzw. compile Anweisungen zu den jeweiligen Versionen gibt es gelegentlich
wenn readthedocs aktualisiert wurde bzw. 
das Geschrei bei reddit zu groß- 
ich persönlich MEIDE reddit, 
einem quasi unregeluliertem Riesenforum NUR für Nerds.
Na Super!

Dort sauber formulierte Informationen ohne jeweilige Anfeindungen zu bekommen,
ist so wahrscheinlich wie aus dem Hamburger Hafen Wein zu schöpfen ;-)

Also ging die Suche los, einen oder mehrere Entwickler richtig "ausfindig" zu machen.
Das ging erstaunlich leicht, wenn man parity als weiteren Parity Client bzw. node.software in Betracht zog.
Diese Software hatte darüberhinaus den Vorteil unglaublich schnell zu synchronisieren#
und außergewöhnlich platzsparend zu arbeiten.
In Rust geschrieben, schnell synchronisierend,
relativ leicht zu erreichende Entwickler- das sag erst einmal gut aus.
Geht aber weiter. Wenn man sich mit Testing so wie ich auseinandersetzt, nimmt man die
persönlichen Lieblinge erst mal aussen vor, und probiert, wie die Software auf älteren bzw. reduzierten Systemen läuft.
Da mir noch etwa 20 notebook und die gleiche Anzahl an raspi2 und 3 aus letzten Projekten zur Verfügung standen,
habe ich auf diesen die ersten "extendet" tests laufen lassen, also die aktuelle
Version von parity runterladen und installieren-
auf dem Raspi 2 ging das eine Zeitlang gut, dann verschwand das github repo und
ich mußte mir anders weiterhelfen.

Nur daß wir uns richtig verstehen-
folgende Nodes waren mal meine:
https://www.ethernodes.org/node/405c0bdc278a9d241adfa4780a5954f4a1253c92abf2b042322d296d364e17af87247be9c4a77fa667122439b7d3159576c4e35dc21272bd1a3e03cfcc464af0
https://www.ethernodes.org/node/6b69fccda9fd26d78521b7444712fe60a6d2d1958e223415267746349ff14c78de2152b99f4a6555b9715d9a5c7b439547b0ff68dec1f5cad3cc84e9f3879f24
https://www.ethernodes.org/node/9b016b11b40afa0c59aab70bef1a6869f772baa243c632730734a793050e5d35c5538ab9f501cfe8d712ffee873d7e1e30e6e603d62bb1ad521b3d359c963240
https://www.ethernodes.org/node/1aceddd3166b3296de078b756b4d899adc3a5e6f59bad0068d18389e0d345a495ec30fbfe33316ced8ff7429a48ce8ba84eae4b6ecace319fb099ae06289e1fa


Um es zu erklären-
innerhalb dieser Liste stehen Clients, deren Architekturen leider nicht als binary supportet werden-
wohl aber auch die "Standard" Version 1.70-64bit
dementsprechend sind dabei:
32bit Parity
raspberry.pi(2).plus

Was mir persönlich bisher komplett schleierhaft ist, warum keine offiziellen 32 bit Clients bereitgestellt werden,
oder eine normale Erzeugung eines raspi2.compatiblen Binary-
es schein aus meiner Sicht, als wenn man sich ausschließlich an aktueller Architektur orieniert,
damit hängt man allerdings einige Regionen der Welt von der Teilnahme fast ab.
Mein Vorschlag ein 32bit build Team zu bilden habe ich bisher für mich behalten-
genauso wie ich den Spaßvögeln mit komplettem raspi image tendenziell Respekt für Ihre Arbeit zolle,
deren Weg zum Image nicht nachvollziehen und diesem für Transaktionen nicht TRAUEN KANN-
vielleicht ist meine Idee über Integrität aber auch zu abgefahren oder en vogue-
mir egal, dachte ich mir und war im April 2017 schon soweit, daß mich parity 
so stark phaszinierte, daß meine Bemühungen in diesem Bereich auf über 40 Stunden die Woche gingen.
War auch sauber möglich, in den letzten Projekten war halt noch ausreichend zu tun, hatte aber keine
Deadlines.

Der Einstieg in Parity geht für mich über Rust am einfachsten und
ich bin nach wie vor ein fan dieser Software, obwohl einige Features inzwischen
verändert wurden. Vielleicht mehr morgen-


