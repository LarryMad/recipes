mir reichts... noch nicht ganz

damit klar wird wovon ich schreibe, eines vorab,
Lesen bildet.
Einbildung ist auch Bildung.

Nun zum finish-

Ich kann über reichhaltige Erfahrungen in den Bereichen

testing in general
plattform testing
liquid documentation
administrational support
international teaming 
interim project management
risc management

schreiben.
Mein Interesse für Ethereum begann in 2015 durch lesen eines Artikels, was ethereum denn überhaupt ist
und wie es funktioniert und weshalb es anders ist, als das was wir kennen.
Es ergab sich, daß im Mai mir 26 potente Grakas ins Haus kamen, die nun nach allen Regeln der Kunst 
umfunktioniert wurden- als miner für ethereum. Um das System zu verstehen, war ich mir nicht zu fein, an dieser Stelle
einige Erahrungen einzusammeln und in den jeweiligen Pools meine Werte einzufahren. Dabei habe ich vorrangig 
unter Windows zunächst gearbeitet, um eine breite Basis an Ansprechpartnern bei der Suche vermuten zu dürfen.
Um das erminte Ether verwalten bzw. transferieren kam ich zunächst aufgrund der Wahl der Plattform auf etherwallet.
Leider ist die Software tendenziell platzverschwenderisch drauf, wenn man die ganze Chain auf den Rechner lädt.
Ein jüngst gefundenes Dokument belegt dies
http://bc.daniel.net.nz/ bzw. deckt sich mit meinen Erfahrungen.
Soweit zu geth, welches einfach ein Wallet-Programm ist, mit dem auch Smart.Contract "gehen".

Nach einer gewissen Erfahrungszeit kam ich dazu, daß ich eine
überzeugende Übersicht aller "möglichen" Clients bzw. Nodes sucht und fand.
Neben Ethereum.Wallet und Mist auf Basis von go bzw. c++ gibt es mehrere beachtenswerte Ansätze,
die auch fortlaufend weiterentwickelt werden. 
Dazu gehören mindestens ethereumJ und pyethapp- diese auf einem Windows System zum laufen zu bringen,
stellt sich als unlösbare Aufgabe bei zahlreichen Versuchen und Umstellungen raus.
Da ich keiner Plattform den absoluten Vorzug gebe, bin ich 
zum "ersten Probieren" im September 2016 dazu übergegangen, weiter auf Linux.Systemen zu arbeiten-
gerade in Hinsicht auf Authentizität und Transparenz.

Mit meiner Wahl eines Linux Mint Debian Edition als Basis.System bestanden die
deutlich höchsten Chancen auf Standards zu treffen, die
vermutlich auch bei mindestens einem der Kernentwickler der jeweiligen
Software vorherrschen.

Exakte aktuelle Hinweise bzw. compile Anweisungen zu den jeweiligen Versionen gibt es gelegentlich
wenn readthedocs aktualisiert wurde bzw. 
das Geschrei bei reddit zu groß- 
ich persönlich MEIDE reddit, 
einem quasi unregeluliertem Riesenforum NUR für Nerds.
Na Super!

Dort sauber formulierte Informationen ohne jeweilige Anfeindungen zu bekommen,
ist so wahrscheinlich wie aus dem Hamburger Hafen Wein zu schöpfen ;-)

Also ging die Suche los, einen oder mehrere Entwickler richtig "ausfindig" zu machen.
Das ging erstaunlich leicht, wenn man parity als weiteren Parity Client bzw. node.software in Betracht zog.
Diese Software hatte darüberhinaus den Vorteil unglaublich schnell zu synchronisieren#
und außergewöhnlich platzsparend zu arbeiten.
In Rust geschrieben, schnell synchronisierend,
relativ leicht zu erreichende Entwickler- das sag erst einmal gut aus.
Geht aber weiter. Wenn man sich mit Testing so wie ich auseinandersetzt, nimmt man die
persönlichen Lieblinge erst mal aussen vor, und probiert, wie die Software auf älteren bzw. reduzierten Systemen läuft.
Da mir noch etwa 20 notebook und die gleiche Anzahl an raspi2 und 3 aus letzten Projekten zur Verfügung standen,
habe ich auf diesen die ersten "extendet" tests laufen lassen, also die aktuelle
Version von parity runterladen und installieren-
auf dem Raspi 2 ging das eine Zeitlang gut, dann verschwand das github repo und
ich mußte mir anders weiterhelfen.
